{"ast":null,"code":"import _toConsumableArray from \"C:/Users/xngar/Desktop/Sanbbox/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/xngar/Desktop/Sanbbox/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/xngar/Desktop/Sanbbox/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"autoplay\", \"delay\", \"driver\", \"keyframes\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\", \"onPlay\", \"onStop\", \"onComplete\", \"onUpdate\"];\nimport { keyframes } from '../../generators/keyframes.mjs';\nimport { spring } from '../../generators/spring/index.mjs';\nimport { inertia } from '../../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../../utils/interpolate.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';\nvar types = {\n  decay: inertia,\n  inertia: inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring: spring\n};\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nvar maxDuration = 20000;\nfunction calculateDuration(generator) {\n  var duration = 0;\n  var timeStep = 50;\n  var state = generator.next(duration);\n  while (!state.done && duration < maxDuration) {\n    duration += timeStep;\n    state = generator.next(duration);\n  }\n  return duration;\n}\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue(_ref) {\n  var _ref$autoplay = _ref.autoplay,\n    autoplay = _ref$autoplay === void 0 ? true : _ref$autoplay,\n    _ref$delay = _ref.delay,\n    delay = _ref$delay === void 0 ? 0 : _ref$delay,\n    _ref$driver = _ref.driver,\n    driver = _ref$driver === void 0 ? frameloopDriver : _ref$driver,\n    keyframes$1 = _ref.keyframes,\n    _ref$type = _ref.type,\n    type = _ref$type === void 0 ? \"keyframes\" : _ref$type,\n    _ref$repeat = _ref.repeat,\n    repeat = _ref$repeat === void 0 ? 0 : _ref$repeat,\n    _ref$repeatDelay = _ref.repeatDelay,\n    repeatDelay = _ref$repeatDelay === void 0 ? 0 : _ref$repeatDelay,\n    _ref$repeatType = _ref.repeatType,\n    repeatType = _ref$repeatType === void 0 ? \"loop\" : _ref$repeatType,\n    onPlay = _ref.onPlay,\n    onStop = _ref.onStop,\n    onComplete = _ref.onComplete,\n    onUpdate = _ref.onUpdate,\n    options = _objectWithoutProperties(_ref, _excluded);\n  var speed = 1;\n  var hasStopped = false;\n  var resolveFinishedPromise;\n  var currentFinishedPromise;\n  /**\n   * Create a new finished Promise every time we enter the\n   * finished state and resolve the old Promise. This is\n   * WAAPI-compatible behaviour.\n   */\n  var updateFinishedPromise = function updateFinishedPromise() {\n    resolveFinishedPromise && resolveFinishedPromise();\n    currentFinishedPromise = new Promise(function (resolve) {\n      resolveFinishedPromise = resolve;\n    });\n  };\n  // Create the first finished promise\n  updateFinishedPromise();\n  var animationDriver;\n  var generatorFactory = types[type] || keyframes;\n  /**\n   * If this isn't the keyframes generator and we've been provided\n   * strings as keyframes, we need to interpolate these.\n   * TODO: Support velocity for units and complex value types/\n   */\n  var mapNumbersToKeyframes;\n  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n  var generator = generatorFactory(_objectSpread(_objectSpread({}, options), {}, {\n    keyframes: keyframes$1\n  }));\n  var mirroredGenerator;\n  if (repeatType === \"mirror\") {\n    mirroredGenerator = generatorFactory(_objectSpread(_objectSpread({}, options), {}, {\n      keyframes: _toConsumableArray(keyframes$1).reverse(),\n      velocity: -(options.velocity || 0)\n    }));\n  }\n  var playState = \"idle\";\n  var holdTime = null;\n  var startTime = null;\n  var cancelTime = null;\n  /**\n   * If duration is undefined and we have repeat options,\n   * we need to calculate a duration from the generator.\n   *\n   * We set it to the generator itself to cache the duration.\n   * Any timeline resolver will need to have already precalculated\n   * the duration by this step.\n   */\n  if (generator.calculatedDuration === null && repeat) {\n    generator.calculatedDuration = calculateDuration(generator);\n  }\n  var calculatedDuration = generator.calculatedDuration;\n  var resolvedDuration = Infinity;\n  var totalDuration = Infinity;\n  if (calculatedDuration !== null) {\n    resolvedDuration = calculatedDuration + repeatDelay;\n    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n  }\n  var time = 0;\n  var tick = function tick(timestamp) {\n    if (startTime === null) return;\n    if (holdTime !== null) {\n      time = holdTime;\n    } else {\n      time = (timestamp - startTime) * speed;\n    }\n    // Rebase on delay\n    time = Math.max(time - delay, 0);\n    /**\n     * If this animation has finished, set the current time\n     * to the total duration.\n     */\n    if (playState === \"finished\" && holdTime === null) {\n      time = totalDuration;\n    }\n    var elapsed = time;\n    var frameGenerator = generator;\n    if (repeat) {\n      /**\n       * Get the current progress (0-1) of the animation. If t is >\n       * than duration we'll get values like 2.5 (midway through the\n       * third iteration)\n       */\n      var progress = time / resolvedDuration;\n      /**\n       * Get the current iteration (0 indexed). For instance the floor of\n       * 2.5 is 2.\n       */\n      var currentIteration = Math.floor(progress);\n      /**\n       * Get the current progress of the iteration by taking the remainder\n       * so 2.5 is 0.5 through iteration 2\n       */\n      var iterationProgress = progress % 1.0;\n      /**\n       * If iteration progress is 1 we count that as the end\n       * of the previous iteration.\n       */\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\n       * Reverse progress if we're not running in \"normal\" direction\n       */\n      var iterationIsOdd = Boolean(currentIteration % 2);\n      if (iterationIsOdd) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n      var p = clamp(0, 1, iterationProgress);\n      if (time > totalDuration) {\n        p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n      }\n      elapsed = p * resolvedDuration;\n    }\n    var state = frameGenerator.next(elapsed);\n    if (mapNumbersToKeyframes) {\n      state.value = mapNumbersToKeyframes(state.value);\n    }\n    var done = state.done;\n    if (calculatedDuration !== null) {\n      done = time >= totalDuration;\n    }\n    var isAnimationFinished = holdTime === null && (playState === \"finished\" || playState === \"running\" && done || speed < 0 && time <= 0);\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n    if (isAnimationFinished) {\n      finish();\n    }\n    return state;\n  };\n  var stopAnimationDriver = function stopAnimationDriver() {\n    animationDriver && animationDriver.stop();\n    animationDriver = undefined;\n  };\n  var _cancel = function cancel() {\n    playState = \"idle\";\n    stopAnimationDriver();\n    updateFinishedPromise();\n    startTime = cancelTime = null;\n  };\n  var finish = function finish() {\n    playState = \"finished\";\n    onComplete && onComplete();\n    stopAnimationDriver();\n    updateFinishedPromise();\n  };\n  var play = function play() {\n    if (hasStopped) return;\n    if (!animationDriver) animationDriver = driver(tick);\n    var now = animationDriver.now();\n    onPlay && onPlay();\n    playState = \"running\";\n    if (holdTime !== null) {\n      startTime = now - holdTime;\n    } else if (!startTime) {\n      // TODO When implementing play/pause, check WAAPI\n      // logic around finished animations\n      startTime = now;\n    }\n    cancelTime = startTime;\n    holdTime = null;\n    animationDriver.start();\n  };\n  if (autoplay) {\n    play();\n  }\n  var controls = {\n    then: function then(resolve, reject) {\n      return currentFinishedPromise.then(resolve, reject);\n    },\n    get time() {\n      return millisecondsToSeconds(time);\n    },\n    set time(newTime) {\n      newTime = secondsToMilliseconds(newTime);\n      time = newTime;\n      if (holdTime !== null || !animationDriver || speed === 0) {\n        holdTime = newTime;\n      } else {\n        startTime = animationDriver.now() - newTime / speed;\n      }\n    },\n    get speed() {\n      return speed;\n    },\n    set speed(newSpeed) {\n      if (newSpeed === speed || !animationDriver) return;\n      speed = newSpeed;\n      controls.time = millisecondsToSeconds(time);\n    },\n    get state() {\n      return playState;\n    },\n    play: play,\n    pause: function pause() {\n      playState = \"paused\";\n      holdTime = time;\n    },\n    stop: function stop() {\n      hasStopped = true;\n      if (playState === \"idle\") return;\n      playState = \"idle\";\n      onStop && onStop();\n      _cancel();\n    },\n    cancel: function cancel() {\n      if (cancelTime !== null) tick(cancelTime);\n      _cancel();\n    },\n    complete: function complete() {\n      playState = \"finished\";\n    },\n    sample: function sample(elapsed) {\n      startTime = 0;\n      return tick(elapsed);\n    }\n  };\n  return controls;\n}\nexport { animateValue };","map":{"version":3,"names":["keyframes","spring","inertia","frameloopDriver","interpolate","clamp","millisecondsToSeconds","secondsToMilliseconds","types","decay","tween","maxDuration","calculateDuration","generator","duration","timeStep","state","next","done","animateValue","_ref","_ref$autoplay","autoplay","_ref$delay","delay","_ref$driver","driver","keyframes$1","_ref$type","type","_ref$repeat","repeat","_ref$repeatDelay","repeatDelay","_ref$repeatType","repeatType","onPlay","onStop","onComplete","onUpdate","options","_objectWithoutProperties","_excluded","speed","hasStopped","resolveFinishedPromise","currentFinishedPromise","updateFinishedPromise","Promise","resolve","animationDriver","generatorFactory","mapNumbersToKeyframes","_objectSpread","mirroredGenerator","_toConsumableArray","reverse","velocity","playState","holdTime","startTime","cancelTime","calculatedDuration","resolvedDuration","Infinity","totalDuration","time","tick","timestamp","Math","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","min","iterationIsOdd","Boolean","p","value","isAnimationFinished","finish","stopAnimationDriver","stop","undefined","cancel","play","now","start","controls","then","reject","newTime","newSpeed","pause","complete","sample"],"sources":["C:/Users/xngar/Desktop/Sanbbox/node_modules/framer-motion/dist/es/animation/animators/js/index.mjs"],"sourcesContent":["import { keyframes } from '../../generators/keyframes.mjs';\nimport { spring } from '../../generators/spring/index.mjs';\nimport { inertia } from '../../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../../utils/interpolate.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';\n\nconst types = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\nfunction calculateDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration;\n}\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\n    let speed = 1;\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Create a new finished Promise every time we enter the\n     * finished state and resolve the old Promise. This is\n     * WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        resolveFinishedPromise && resolveFinishedPromise();\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let animationDriver;\n    const generatorFactory = types[type] || keyframes;\n    /**\n     * If this isn't the keyframes generator and we've been provided\n     * strings as keyframes, we need to interpolate these.\n     * TODO: Support velocity for units and complex value types/\n     */\n    let mapNumbersToKeyframes;\n    if (generatorFactory !== keyframes &&\n        typeof keyframes$1[0] !== \"number\") {\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n    let mirroredGenerator;\n    if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory({\n            ...options,\n            keyframes: [...keyframes$1].reverse(),\n            velocity: -(options.velocity || 0),\n        });\n    }\n    let playState = \"idle\";\n    let holdTime = null;\n    let startTime = null;\n    let cancelTime = null;\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null && repeat) {\n        generator.calculatedDuration = calculateDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    let resolvedDuration = Infinity;\n    let totalDuration = Infinity;\n    if (calculatedDuration !== null) {\n        resolvedDuration = calculatedDuration + repeatDelay;\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    }\n    let time = 0;\n    const tick = (timestamp) => {\n        if (startTime === null)\n            return;\n        if (holdTime !== null) {\n            time = holdTime;\n        }\n        else {\n            time = (timestamp - startTime) * speed;\n        }\n        // Rebase on delay\n        time = Math.max(time - delay, 0);\n        /**\n         * If this animation has finished, set the current time\n         * to the total duration.\n         */\n        if (playState === \"finished\" && holdTime === null) {\n            time = totalDuration;\n        }\n        let elapsed = time;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = time / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = Boolean(currentIteration % 2);\n            if (iterationIsOdd) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            let p = clamp(0, 1, iterationProgress);\n            if (time > totalDuration) {\n                p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n            }\n            elapsed = p * resolvedDuration;\n        }\n        const state = frameGenerator.next(elapsed);\n        if (mapNumbersToKeyframes) {\n            state.value = mapNumbersToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (calculatedDuration !== null) {\n            done = time >= totalDuration;\n        }\n        const isAnimationFinished = holdTime === null &&\n            (playState === \"finished\" ||\n                (playState === \"running\" && done) ||\n                (speed < 0 && time <= 0));\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            finish();\n        }\n        return state;\n    };\n    const stopAnimationDriver = () => {\n        animationDriver && animationDriver.stop();\n        animationDriver = undefined;\n    };\n    const cancel = () => {\n        playState = \"idle\";\n        stopAnimationDriver();\n        updateFinishedPromise();\n        startTime = cancelTime = null;\n    };\n    const finish = () => {\n        playState = \"finished\";\n        onComplete && onComplete();\n        stopAnimationDriver();\n        updateFinishedPromise();\n    };\n    const play = () => {\n        if (hasStopped)\n            return;\n        if (!animationDriver)\n            animationDriver = driver(tick);\n        const now = animationDriver.now();\n        onPlay && onPlay();\n        playState = \"running\";\n        if (holdTime !== null) {\n            startTime = now - holdTime;\n        }\n        else if (!startTime) {\n            // TODO When implementing play/pause, check WAAPI\n            // logic around finished animations\n            startTime = now;\n        }\n        cancelTime = startTime;\n        holdTime = null;\n        animationDriver.start();\n    };\n    if (autoplay) {\n        play();\n    }\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        get time() {\n            return millisecondsToSeconds(time);\n        },\n        set time(newTime) {\n            newTime = secondsToMilliseconds(newTime);\n            time = newTime;\n            if (holdTime !== null || !animationDriver || speed === 0) {\n                holdTime = newTime;\n            }\n            else {\n                startTime = animationDriver.now() - newTime / speed;\n            }\n        },\n        get speed() {\n            return speed;\n        },\n        set speed(newSpeed) {\n            if (newSpeed === speed || !animationDriver)\n                return;\n            speed = newSpeed;\n            controls.time = millisecondsToSeconds(time);\n        },\n        get state() {\n            return playState;\n        },\n        play,\n        pause: () => {\n            playState = \"paused\";\n            holdTime = time;\n        },\n        stop: () => {\n            hasStopped = true;\n            if (playState === \"idle\")\n                return;\n            playState = \"idle\";\n            onStop && onStop();\n            cancel();\n        },\n        cancel: () => {\n            if (cancelTime !== null)\n                tick(cancelTime);\n            cancel();\n        },\n        complete: () => {\n            playState = \"finished\";\n        },\n        sample: (elapsed) => {\n            startTime = 0;\n            return tick(elapsed);\n        },\n    };\n    return controls;\n}\n\nexport { animateValue };\n"],"mappings":";;;;AAAA,SAASA,SAAS,QAAQ,gCAAgC;AAC1D,SAASC,MAAM,QAAQ,mCAAmC;AAC1D,SAASC,OAAO,QAAQ,8BAA8B;AACtD,SAASC,eAAe,QAAQ,wBAAwB;AACxD,SAASC,WAAW,QAAQ,gCAAgC;AAC5D,SAASC,KAAK,QAAQ,0BAA0B;AAChD,SAASC,qBAAqB,EAAEC,qBAAqB,QAAQ,oCAAoC;AAEjG,IAAMC,KAAK,GAAG;EACVC,KAAK,EAAEP,OAAO;EACdA,OAAO,EAAPA,OAAO;EACPQ,KAAK,EAAEV,SAAS;EAChBA,SAAS,EAAEA,SAAS;EACpBC,MAAM,EAANA;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA,IAAMU,WAAW,GAAG,KAAK;AACzB,SAASC,iBAAiBA,CAACC,SAAS,EAAE;EAClC,IAAIC,QAAQ,GAAG,CAAC;EAChB,IAAMC,QAAQ,GAAG,EAAE;EACnB,IAAIC,KAAK,GAAGH,SAAS,CAACI,IAAI,CAACH,QAAQ,CAAC;EACpC,OAAO,CAACE,KAAK,CAACE,IAAI,IAAIJ,QAAQ,GAAGH,WAAW,EAAE;IAC1CG,QAAQ,IAAIC,QAAQ;IACpBC,KAAK,GAAGH,SAAS,CAACI,IAAI,CAACH,QAAQ,CAAC;EACpC;EACA,OAAOA,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,YAAYA,CAAAC,IAAA,EAA2M;EAAA,IAAAC,aAAA,GAAAD,IAAA,CAAxME,QAAQ;IAARA,QAAQ,GAAAD,aAAA,cAAG,IAAI,GAAAA,aAAA;IAAAE,UAAA,GAAAH,IAAA,CAAEI,KAAK;IAALA,KAAK,GAAAD,UAAA,cAAG,CAAC,GAAAA,UAAA;IAAAE,WAAA,GAAAL,IAAA,CAAEM,MAAM;IAANA,MAAM,GAAAD,WAAA,cAAGtB,eAAe,GAAAsB,WAAA;IAAaE,WAAW,GAAAP,IAAA,CAAtBpB,SAAS;IAAA4B,SAAA,GAAAR,IAAA,CAAeS,IAAI;IAAJA,IAAI,GAAAD,SAAA,cAAG,WAAW,GAAAA,SAAA;IAAAE,WAAA,GAAAV,IAAA,CAAEW,MAAM;IAANA,MAAM,GAAAD,WAAA,cAAG,CAAC,GAAAA,WAAA;IAAAE,gBAAA,GAAAZ,IAAA,CAAEa,WAAW;IAAXA,WAAW,GAAAD,gBAAA,cAAG,CAAC,GAAAA,gBAAA;IAAAE,eAAA,GAAAd,IAAA,CAAEe,UAAU;IAAVA,UAAU,GAAAD,eAAA,cAAG,MAAM,GAAAA,eAAA;IAAEE,MAAM,GAAAhB,IAAA,CAANgB,MAAM;IAAEC,MAAM,GAAAjB,IAAA,CAANiB,MAAM;IAAEC,UAAU,GAAAlB,IAAA,CAAVkB,UAAU;IAAEC,QAAQ,GAAAnB,IAAA,CAARmB,QAAQ;IAAKC,OAAO,GAAAC,wBAAA,CAAArB,IAAA,EAAAsB,SAAA;EACxN,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIC,sBAAsB;EAC1B,IAAIC,sBAAsB;EAC1B;AACJ;AACA;AACA;AACA;EACI,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAAA,EAAS;IAChCF,sBAAsB,IAAIA,sBAAsB,EAAE;IAClDC,sBAAsB,GAAG,IAAIE,OAAO,CAAC,UAACC,OAAO,EAAK;MAC9CJ,sBAAsB,GAAGI,OAAO;IACpC,CAAC,CAAC;EACN,CAAC;EACD;EACAF,qBAAqB,EAAE;EACvB,IAAIG,eAAe;EACnB,IAAMC,gBAAgB,GAAG3C,KAAK,CAACqB,IAAI,CAAC,IAAI7B,SAAS;EACjD;AACJ;AACA;AACA;AACA;EACI,IAAIoD,qBAAqB;EACzB,IAAID,gBAAgB,KAAKnD,SAAS,IAC9B,OAAO2B,WAAW,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;IACpCyB,qBAAqB,GAAGhD,WAAW,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAEuB,WAAW,EAAE;MACvDtB,KAAK,EAAE;IACX,CAAC,CAAC;IACFsB,WAAW,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;EAC1B;EACA,IAAMd,SAAS,GAAGsC,gBAAgB,CAAAE,aAAA,CAAAA,aAAA,KAAMb,OAAO;IAAExC,SAAS,EAAE2B;EAAW,GAAG;EAC1E,IAAI2B,iBAAiB;EACrB,IAAInB,UAAU,KAAK,QAAQ,EAAE;IACzBmB,iBAAiB,GAAGH,gBAAgB,CAAAE,aAAA,CAAAA,aAAA,KAC7Bb,OAAO;MACVxC,SAAS,EAAEuD,kBAAA,CAAI5B,WAAW,EAAE6B,OAAO,EAAE;MACrCC,QAAQ,EAAE,EAAEjB,OAAO,CAACiB,QAAQ,IAAI,CAAC;IAAC,GACpC;EACN;EACA,IAAIC,SAAS,GAAG,MAAM;EACtB,IAAIC,QAAQ,GAAG,IAAI;EACnB,IAAIC,SAAS,GAAG,IAAI;EACpB,IAAIC,UAAU,GAAG,IAAI;EACrB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIhD,SAAS,CAACiD,kBAAkB,KAAK,IAAI,IAAI/B,MAAM,EAAE;IACjDlB,SAAS,CAACiD,kBAAkB,GAAGlD,iBAAiB,CAACC,SAAS,CAAC;EAC/D;EACA,IAAQiD,kBAAkB,GAAKjD,SAAS,CAAhCiD,kBAAkB;EAC1B,IAAIC,gBAAgB,GAAGC,QAAQ;EAC/B,IAAIC,aAAa,GAAGD,QAAQ;EAC5B,IAAIF,kBAAkB,KAAK,IAAI,EAAE;IAC7BC,gBAAgB,GAAGD,kBAAkB,GAAG7B,WAAW;IACnDgC,aAAa,GAAGF,gBAAgB,IAAIhC,MAAM,GAAG,CAAC,CAAC,GAAGE,WAAW;EACjE;EACA,IAAIiC,IAAI,GAAG,CAAC;EACZ,IAAMC,IAAI,GAAG,SAAPA,IAAIA,CAAIC,SAAS,EAAK;IACxB,IAAIR,SAAS,KAAK,IAAI,EAClB;IACJ,IAAID,QAAQ,KAAK,IAAI,EAAE;MACnBO,IAAI,GAAGP,QAAQ;IACnB,CAAC,MACI;MACDO,IAAI,GAAG,CAACE,SAAS,GAAGR,SAAS,IAAIjB,KAAK;IAC1C;IACA;IACAuB,IAAI,GAAGG,IAAI,CAACC,GAAG,CAACJ,IAAI,GAAG1C,KAAK,EAAE,CAAC,CAAC;IAChC;AACR;AACA;AACA;IACQ,IAAIkC,SAAS,KAAK,UAAU,IAAIC,QAAQ,KAAK,IAAI,EAAE;MAC/CO,IAAI,GAAGD,aAAa;IACxB;IACA,IAAIM,OAAO,GAAGL,IAAI;IAClB,IAAIM,cAAc,GAAG3D,SAAS;IAC9B,IAAIkB,MAAM,EAAE;MACR;AACZ;AACA;AACA;AACA;MACY,IAAM0C,QAAQ,GAAGP,IAAI,GAAGH,gBAAgB;MACxC;AACZ;AACA;AACA;MACY,IAAIW,gBAAgB,GAAGL,IAAI,CAACM,KAAK,CAACF,QAAQ,CAAC;MAC3C;AACZ;AACA;AACA;MACY,IAAIG,iBAAiB,GAAGH,QAAQ,GAAG,GAAG;MACtC;AACZ;AACA;AACA;MACY,IAAI,CAACG,iBAAiB,IAAIH,QAAQ,IAAI,CAAC,EAAE;QACrCG,iBAAiB,GAAG,CAAC;MACzB;MACAA,iBAAiB,KAAK,CAAC,IAAIF,gBAAgB,EAAE;MAC7CA,gBAAgB,GAAGL,IAAI,CAACQ,GAAG,CAACH,gBAAgB,EAAE3C,MAAM,GAAG,CAAC,CAAC;MACzD;AACZ;AACA;MACY,IAAM+C,cAAc,GAAGC,OAAO,CAACL,gBAAgB,GAAG,CAAC,CAAC;MACpD,IAAII,cAAc,EAAE;QAChB,IAAI3C,UAAU,KAAK,SAAS,EAAE;UAC1ByC,iBAAiB,GAAG,CAAC,GAAGA,iBAAiB;UACzC,IAAI3C,WAAW,EAAE;YACb2C,iBAAiB,IAAI3C,WAAW,GAAG8B,gBAAgB;UACvD;QACJ,CAAC,MACI,IAAI5B,UAAU,KAAK,QAAQ,EAAE;UAC9BqC,cAAc,GAAGlB,iBAAiB;QACtC;MACJ;MACA,IAAI0B,CAAC,GAAG3E,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEuE,iBAAiB,CAAC;MACtC,IAAIV,IAAI,GAAGD,aAAa,EAAE;QACtBe,CAAC,GAAG7C,UAAU,KAAK,SAAS,IAAI2C,cAAc,GAAG,CAAC,GAAG,CAAC;MAC1D;MACAP,OAAO,GAAGS,CAAC,GAAGjB,gBAAgB;IAClC;IACA,IAAM/C,KAAK,GAAGwD,cAAc,CAACvD,IAAI,CAACsD,OAAO,CAAC;IAC1C,IAAInB,qBAAqB,EAAE;MACvBpC,KAAK,CAACiE,KAAK,GAAG7B,qBAAqB,CAACpC,KAAK,CAACiE,KAAK,CAAC;IACpD;IACA,IAAM/D,IAAI,GAAKF,KAAK,CAAdE,IAAI;IACV,IAAI4C,kBAAkB,KAAK,IAAI,EAAE;MAC7B5C,IAAI,GAAGgD,IAAI,IAAID,aAAa;IAChC;IACA,IAAMiB,mBAAmB,GAAGvB,QAAQ,KAAK,IAAI,KACxCD,SAAS,KAAK,UAAU,IACpBA,SAAS,KAAK,SAAS,IAAIxC,IAAK,IAChCyB,KAAK,GAAG,CAAC,IAAIuB,IAAI,IAAI,CAAE,CAAC;IACjC,IAAI3B,QAAQ,EAAE;MACVA,QAAQ,CAACvB,KAAK,CAACiE,KAAK,CAAC;IACzB;IACA,IAAIC,mBAAmB,EAAE;MACrBC,MAAM,EAAE;IACZ;IACA,OAAOnE,KAAK;EAChB,CAAC;EACD,IAAMoE,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAA,EAAS;IAC9BlC,eAAe,IAAIA,eAAe,CAACmC,IAAI,EAAE;IACzCnC,eAAe,GAAGoC,SAAS;EAC/B,CAAC;EACD,IAAMC,OAAM,GAAG,SAATA,MAAMA,CAAA,EAAS;IACjB7B,SAAS,GAAG,MAAM;IAClB0B,mBAAmB,EAAE;IACrBrC,qBAAqB,EAAE;IACvBa,SAAS,GAAGC,UAAU,GAAG,IAAI;EACjC,CAAC;EACD,IAAMsB,MAAM,GAAG,SAATA,MAAMA,CAAA,EAAS;IACjBzB,SAAS,GAAG,UAAU;IACtBpB,UAAU,IAAIA,UAAU,EAAE;IAC1B8C,mBAAmB,EAAE;IACrBrC,qBAAqB,EAAE;EAC3B,CAAC;EACD,IAAMyC,IAAI,GAAG,SAAPA,IAAIA,CAAA,EAAS;IACf,IAAI5C,UAAU,EACV;IACJ,IAAI,CAACM,eAAe,EAChBA,eAAe,GAAGxB,MAAM,CAACyC,IAAI,CAAC;IAClC,IAAMsB,GAAG,GAAGvC,eAAe,CAACuC,GAAG,EAAE;IACjCrD,MAAM,IAAIA,MAAM,EAAE;IAClBsB,SAAS,GAAG,SAAS;IACrB,IAAIC,QAAQ,KAAK,IAAI,EAAE;MACnBC,SAAS,GAAG6B,GAAG,GAAG9B,QAAQ;IAC9B,CAAC,MACI,IAAI,CAACC,SAAS,EAAE;MACjB;MACA;MACAA,SAAS,GAAG6B,GAAG;IACnB;IACA5B,UAAU,GAAGD,SAAS;IACtBD,QAAQ,GAAG,IAAI;IACfT,eAAe,CAACwC,KAAK,EAAE;EAC3B,CAAC;EACD,IAAIpE,QAAQ,EAAE;IACVkE,IAAI,EAAE;EACV;EACA,IAAMG,QAAQ,GAAG;IACbC,IAAI,WAAAA,KAAC3C,OAAO,EAAE4C,MAAM,EAAE;MAClB,OAAO/C,sBAAsB,CAAC8C,IAAI,CAAC3C,OAAO,EAAE4C,MAAM,CAAC;IACvD,CAAC;IACD,IAAI3B,IAAIA,CAAA,EAAG;MACP,OAAO5D,qBAAqB,CAAC4D,IAAI,CAAC;IACtC,CAAC;IACD,IAAIA,IAAIA,CAAC4B,OAAO,EAAE;MACdA,OAAO,GAAGvF,qBAAqB,CAACuF,OAAO,CAAC;MACxC5B,IAAI,GAAG4B,OAAO;MACd,IAAInC,QAAQ,KAAK,IAAI,IAAI,CAACT,eAAe,IAAIP,KAAK,KAAK,CAAC,EAAE;QACtDgB,QAAQ,GAAGmC,OAAO;MACtB,CAAC,MACI;QACDlC,SAAS,GAAGV,eAAe,CAACuC,GAAG,EAAE,GAAGK,OAAO,GAAGnD,KAAK;MACvD;IACJ,CAAC;IACD,IAAIA,KAAKA,CAAA,EAAG;MACR,OAAOA,KAAK;IAChB,CAAC;IACD,IAAIA,KAAKA,CAACoD,QAAQ,EAAE;MAChB,IAAIA,QAAQ,KAAKpD,KAAK,IAAI,CAACO,eAAe,EACtC;MACJP,KAAK,GAAGoD,QAAQ;MAChBJ,QAAQ,CAACzB,IAAI,GAAG5D,qBAAqB,CAAC4D,IAAI,CAAC;IAC/C,CAAC;IACD,IAAIlD,KAAKA,CAAA,EAAG;MACR,OAAO0C,SAAS;IACpB,CAAC;IACD8B,IAAI,EAAJA,IAAI;IACJQ,KAAK,EAAE,SAAAA,MAAA,EAAM;MACTtC,SAAS,GAAG,QAAQ;MACpBC,QAAQ,GAAGO,IAAI;IACnB,CAAC;IACDmB,IAAI,EAAE,SAAAA,KAAA,EAAM;MACRzC,UAAU,GAAG,IAAI;MACjB,IAAIc,SAAS,KAAK,MAAM,EACpB;MACJA,SAAS,GAAG,MAAM;MAClBrB,MAAM,IAAIA,MAAM,EAAE;MAClBkD,OAAM,EAAE;IACZ,CAAC;IACDA,MAAM,EAAE,SAAAA,OAAA,EAAM;MACV,IAAI1B,UAAU,KAAK,IAAI,EACnBM,IAAI,CAACN,UAAU,CAAC;MACpB0B,OAAM,EAAE;IACZ,CAAC;IACDU,QAAQ,EAAE,SAAAA,SAAA,EAAM;MACZvC,SAAS,GAAG,UAAU;IAC1B,CAAC;IACDwC,MAAM,EAAE,SAAAA,OAAC3B,OAAO,EAAK;MACjBX,SAAS,GAAG,CAAC;MACb,OAAOO,IAAI,CAACI,OAAO,CAAC;IACxB;EACJ,CAAC;EACD,OAAOoB,QAAQ;AACnB;AAEA,SAASxE,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}